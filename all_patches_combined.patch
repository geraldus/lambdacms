diff -urN a/Application.hs b/Application.hs
--- a/Application.hs	2015-02-03 10:43:23.000000000 +0100
+++ b/Application.hs	2015-02-03 17:16:18.000000000 +0100
@@ -21,12 +21,19 @@
                                              mkRequestLogger, outputFormat)
 import System.Log.FastLogger                (defaultBufSize, newStdoutLoggerSet,
                                              toLogStr)
+import LambdaCms.Core
+import LambdaCms.Core.Settings (generateUUID)
+import Network.Wai.Middleware.MethodOverridePost
 
 -- Import all relevant handler modules here.
 -- Don't forget to add new modules to your cabal file!
 import Handler.Common
 import Handler.Home
 
+getAdminHomeRedirectR :: Handler Html
+getAdminHomeRedirectR = do
+    redirect $ CoreAdminR AdminHomeR
+
 -- This line actually creates our YesodDispatch instance. It is the second half
 -- of the call to mkYesodData which occurs in Foundation.hs. Please see the
 -- comments there for more details.
@@ -51,7 +58,8 @@
     -- logging function. To get out of this loop, we initially create a
     -- temporary foundation without a real connection pool, get a log function
     -- from there, and then create the real foundation.
-    let mkFoundation appConnPool = App {..}
+    let getLambdaCms = CoreAdmin
+        mkFoundation appConnPool = App {..}
         tempFoundation = mkFoundation $ error "connPool forced in tempFoundation"
         logFunc = messageLoggerSource tempFoundation appLogger
 
@@ -60,11 +68,36 @@
         (pgConnStr  $ appDatabaseConf appSettings)
         (pgPoolSize $ appDatabaseConf appSettings)
 
+    let theFoundation = mkFoundation pool
     -- Perform database migration using our application's logging settings.
-    runLoggingT (runSqlPool (runMigration migrateAll) pool) logFunc
+    runLoggingT
+        (runSqlPool (mapM_ runMigration [migrateAll, migrateLambdaCmsCore]) pool)
+        (messageLoggerSource theFoundation appLogger)
+
+    -- Create a user if no user exists yet
+    let admin = appAdmin appSettings
+    madmin <- runSqlPool (getBy (UniqueEmail admin)) pool
+    case madmin of
+        Nothing -> do
+            timeNow <- getCurrentTime
+            uuid <- generateUUID
+            flip runSqlPool pool $ do
+                uid <- insert User { userIdent     = uuid
+                                   , userPassword  = Nothing
+                                   , userName      = takeWhile (/= '@') admin
+                                   , userEmail     = admin
+                                   , userActive    = True
+                                   , userToken     = Nothing
+                                   , userCreatedAt = timeNow
+                                   , userLastLogin = Nothing
+                                   , userDeletedAt = Nothing
+                                   }
+                -- assign all roles to the first user
+                mapM_ (insert_ . UserRole uid) [minBound .. maxBound]
+        _ -> return ()
 
     -- Return the foundation
-    return $ mkFoundation pool
+    return theFoundation
 
 -- | Convert our foundation to a WAI Application by calling @toWaiAppPlain@ and
 -- applyng some additional middlewares.
@@ -83,7 +116,7 @@
 
     -- Create the WAI application and apply middlewares
     appPlain <- toWaiAppPlain foundation
-    return $ logWare $ defaultMiddlewaresNoLogging appPlain
+    return $ logWare $ methodOverridePost appPlain
 
 -- | Warp settings for the given foundation value.
 warpSettings :: App -> Settings
diff -urN a/Foundation.hs b/Foundation.hs
--- a/Foundation.hs	2015-02-03 10:43:23.000000000 +0100
+++ b/Foundation.hs	2015-02-03 17:24:54.000000000 +0100
@@ -7,6 +7,10 @@
 import Yesod.Auth.BrowserId (authBrowserId)
 import Yesod.Default.Util   (addStaticContentExternal)
 import Yesod.Core.Types     (Logger)
+import qualified Data.Set                    as S
+import qualified Network.Wai                 as W
+import LambdaCms.Core
+import Roles
 
 -- | The foundation datatype for your application. This can be a good place to
 -- keep settings and values requiring initialization before your application
@@ -18,6 +22,7 @@
     , appConnPool    :: ConnectionPool -- ^ Database connection pool.
     , appHttpManager :: Manager
     , appLogger      :: Logger
+    , getLambdaCms   :: CoreAdmin
     }
 
 instance HasHttpManager App where
@@ -67,11 +72,14 @@
     authRoute _ = Just $ AuthR LoginR
 
     -- Routes not requiring authentication.
-    isAuthorized (AuthR _) _ = return Authorized
-    isAuthorized FaviconR _ = return Authorized
-    isAuthorized RobotsR _ = return Authorized
-    -- Default to Authorized for now.
-    isAuthorized _ _ = return Authorized
+    isAuthorized (StaticR _)                   _ = return Authorized
+    isAuthorized (CoreAdminR (AdminStaticR _)) _ = return Authorized
+    isAuthorized theRoute                      _ = do
+        mauthId <- maybeAuthId
+        wai     <- waiRequest
+        y       <- getYesod
+        murs    <- mapM getUserRoles mauthId
+        return $ isAuthorizedTo y murs $ actionAllowedFor theRoute (W.requestMethod wai)
 
     -- This function creates static content files in the static folder
     -- and names them based on a hash of their content. This allows
@@ -114,27 +122,21 @@
     type AuthId App = UserId
 
     -- Where to send a user after successful login
-    loginDest _ = HomeR
+    loginDest _ = CoreAdminR AdminHomeR
     -- Where to send a user after logout
-    logoutDest _ = HomeR
+    logoutDest _ = AuthR LoginR
     -- Override the above two destinations when a Referer: header is present
     redirectToReferer _ = True
 
-    getAuthId creds = runDB $ do
-        x <- getBy $ UniqueUser $ credsIdent creds
-        case x of
-            Just (Entity uid _) -> return $ Just uid
-            Nothing -> do
-                fmap Just $ insert User
-                    { userIdent = credsIdent creds
-                    , userPassword = Nothing
-                    }
+    getAuthId = getLambdaCmsAuthId
 
     -- You can add other plugins like BrowserID, email or OAuth here
     authPlugins _ = [authBrowserId def]
 
     authHttpManager = getHttpManager
 
+    authLayout = adminAuthLayout
+
 instance YesodAuthPersist App
 
 -- This instance is required to use forms. You can modify renderMessage to
@@ -149,3 +151,37 @@
 -- https://github.com/yesodweb/yesod/wiki/Sending-email
 -- https://github.com/yesodweb/yesod/wiki/Serve-static-files-from-a-separate-domain
 -- https://github.com/yesodweb/yesod/wiki/i18n-messages-in-the-scaffolding
+
+instance LambdaCmsAdmin App where
+    type Roles App = RoleName
+
+    actionAllowedFor (FaviconR) "GET" = Unauthenticated
+    actionAllowedFor (RobotsR)  "GET" = Unauthenticated
+    actionAllowedFor (HomeR)    "GET" = Unauthenticated
+    actionAllowedFor (AuthR _)  _     = Unauthenticated
+    actionAllowedFor _          _     = Roles $ S.fromList [Admin]
+
+    coreR = CoreAdminR
+    authR = AuthR
+    masterHomeR = HomeR
+
+    -- cache user roles to reduce the amount of DB calls
+    getUserRoles userId = cachedBy cacheKey . fmap toRoleSet . runDB $ selectList [UserRoleUserId ==. userId] []
+        where
+            cacheKey = encodeUtf8 $ toPathPiece userId
+            toRoleSet = S.fromList . map (userRoleRoleName . entityVal)
+
+    setUserRoles userId rs = runDB $ do
+        deleteWhere [UserRoleUserId ==. userId]
+        mapM_ (insert_ . UserRole userId) $ S.toList rs
+
+    adminMenu =  (defaultCoreAdminMenu CoreAdminR)
+    renderLanguages _ = ["en", "nl"]
+
+    mayAssignRoles = do
+        authId <- requireAuthId
+        roles <- getUserRoles authId
+        return $ isAdmin roles
+
+isAdmin :: S.Set RoleName -> Bool
+isAdmin = S.member Admin
diff -urN a/Model.hs b/Model.hs
--- a/Model.hs	2015-02-03 10:43:23.000000000 +0100
+++ b/Model.hs	2015-02-03 10:52:44.000000000 +0100
@@ -3,6 +3,9 @@
 import ClassyPrelude.Yesod
 import Database.Persist.Quasi
 
+import Roles
+import LambdaCms.Core
+
 -- You can define all of your database entities in the entities file.
 -- You can find more information on persistent and how to declare entities
 -- at:
diff -urN a/Roles.hs b/Roles.hs
--- a/Roles.hs	1970-01-01 01:00:00.000000000 +0100
+++ b/Roles.hs	2015-02-03 10:57:56.000000000 +0100
@@ -0,0 +1,9 @@
+module Roles where
+
+import ClassyPrelude.Yesod
+
+data RoleName = Admin
+              | Blogger
+              deriving (Eq, Ord, Show, Read, Enum, Bounded, Typeable)
+
+derivePersistField "RoleName"
diff -urN a/Settings.hs b/Settings.hs
--- a/Settings.hs	2015-02-03 10:43:23.000000000 +0100
+++ b/Settings.hs	2015-02-03 11:07:59.000000000 +0100
@@ -52,6 +52,8 @@
     -- ^ Copyright text to appear in the footer of the page
     , appAnalytics              :: Maybe Text
     -- ^ Google Analytics code
+    , appAdmin                  :: Text
+    -- ^ LambdaCms default admin email address
     }
 
 instance FromJSON AppSettings where
@@ -78,6 +80,8 @@
         appCopyright              <- o .: "copyright"
         appAnalytics              <- o .:? "analytics"
 
+        appAdmin                  <- o .: "admin"
+
         return AppSettings {..}
 
 -- | Settings for 'widgetFile', such as which template languages to support and
diff -urN a/config/models b/config/models
--- a/config/models	2015-02-03 10:43:23.000000000 +0100
+++ b/config/models	2015-02-03 10:52:04.000000000 +0100
@@ -1,12 +1,5 @@
-User
-    ident Text
-    password Text Maybe
-    UniqueUser ident
-    deriving Typeable
-Email
-    email Text
-    user UserId Maybe
-    verkey Text Maybe
-    UniqueEmail email
-
- -- By default this file is used in Model.hs (which is imported by Foundation.hs)
+UserRole
+    userId UserId
+    roleName RoleName
+    UniqueUserRole userId roleName
+    deriving Typeable Show
diff -urN a/config/routes b/config/routes
--- a/config/routes	2015-02-03 10:43:23.000000000 +0100
+++ b/config/routes	2015-02-03 10:48:12.000000000 +0100
@@ -1,7 +1,10 @@
 /static StaticR Static appStatic
-/auth   AuthR   Auth   getAuth
 
 /favicon.ico FaviconR GET
 /robots.txt RobotsR GET
 
 / HomeR GET POST
+
+/admin/auth   AuthR                Auth         getAuth
+/admin/core   CoreAdminR           CoreAdmin    getLambdaCms
+/admin        AdminHomeRedirectR   GET
diff -urN a/config/settings.yml b/config/settings.yml
--- a/config/settings.yml	2015-02-03 10:43:23.000000000 +0100
+++ b/config/settings.yml	2015-02-03 11:13:22.000000000 +0100
@@ -27,3 +27,5 @@
 
 copyright: Insert copyright statement here
 #analytics: UA-YOURCODE
+
+#admin: "_env:LAMBDACMS_ADMIN:<your email address>"
diff -urN a/patch.cabal b/patch.cabal
--- a/patch.cabal	2015-02-03 10:43:23.000000000 +0100
+++ b/patch.cabal	2015-02-03 10:46:26.000000000 +0100
@@ -21,6 +21,7 @@
                      Settings.StaticFiles
                      Handler.Common
                      Handler.Home
+                     Roles
 
     if flag(dev) || flag(library-only)
         cpp-options:   -DDEVELOPMENT
@@ -80,6 +81,8 @@
                  , containers
                  , vector
                  , time
+                 , lambdacms-core                >= 0.0.7      && < 0.1
+                 , wai                           >= 3.0.2      && < 3.1
 
 executable         patch
     if flag(library-only)
diff -urN a/test/Handler/HomeSpec.hs b/test/Handler/HomeSpec.hs
--- a/test/Handler/HomeSpec.hs	2015-02-03 10:43:23.000000000 +0100
+++ b/test/Handler/HomeSpec.hs	2015-02-03 11:10:13.000000000 +0100
@@ -25,8 +25,8 @@
     -- This is a simple example of using a database access in a test.  The
     -- test will succeed for a fresh scaffolded site with an empty database,
     -- but will fail on an existing database with a non-empty user table.
-    it "leaves the user table empty" $ do
-        get HomeR
-        statusIs 200
-        users <- runDB $ selectList ([] :: [Filter User]) []
-        assertEqual "user table empty" 0 $ length users
+    -- it "leaves the user table empty" $ do
+    --     get HomeR
+    --     statusIs 200
+    --     users <- runDB $ selectList ([] :: [Filter User]) []
+    --     assertEqual "user table empty" 0 $ length users
