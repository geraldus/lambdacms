--- a/Application.hs	2015-02-03 10:43:23.000000000 +0100
+++ b/Application.hs	2015-02-03 17:16:18.000000000 +0100
@@ -21,12 +21,19 @@
                                              mkRequestLogger, outputFormat)
 import System.Log.FastLogger                (defaultBufSize, newStdoutLoggerSet,
                                              toLogStr)
+import LambdaCms.Core
+import LambdaCms.Core.Settings (generateUUID)
+import Network.Wai.Middleware.MethodOverridePost
 
 -- Import all relevant handler modules here.
 -- Don't forget to add new modules to your cabal file!
 import Handler.Common
 import Handler.Home
 
+getAdminHomeRedirectR :: Handler Html
+getAdminHomeRedirectR = do
+    redirect $ CoreAdminR AdminHomeR
+
 -- This line actually creates our YesodDispatch instance. It is the second half
 -- of the call to mkYesodData which occurs in Foundation.hs. Please see the
 -- comments there for more details.
@@ -51,7 +58,8 @@
     -- logging function. To get out of this loop, we initially create a
     -- temporary foundation without a real connection pool, get a log function
     -- from there, and then create the real foundation.
-    let mkFoundation appConnPool = App {..}
+    let getLambdaCms = CoreAdmin
+        mkFoundation appConnPool = App {..}
         tempFoundation = mkFoundation $ error "connPool forced in tempFoundation"
         logFunc = messageLoggerSource tempFoundation appLogger
 
@@ -60,11 +68,36 @@
         (pgConnStr  $ appDatabaseConf appSettings)
         (pgPoolSize $ appDatabaseConf appSettings)
 
+    let theFoundation = mkFoundation pool
     -- Perform database migration using our application's logging settings.
-    runLoggingT (runSqlPool (runMigration migrateAll) pool) logFunc
+    runLoggingT
+        (runSqlPool (mapM_ runMigration [migrateAll, migrateLambdaCmsCore]) pool)
+        (messageLoggerSource theFoundation appLogger)
+
+    -- Create a user if no user exists yet
+    let admin = appAdmin appSettings
+    madmin <- runSqlPool (getBy (UniqueEmail admin)) pool
+    case madmin of
+        Nothing -> do
+            timeNow <- getCurrentTime
+            uuid <- generateUUID
+            flip runSqlPool pool $ do
+                uid <- insert User { userIdent     = uuid
+                                   , userPassword  = Nothing
+                                   , userName      = takeWhile (/= '@') admin
+                                   , userEmail     = admin
+                                   , userActive    = True
+                                   , userToken     = Nothing
+                                   , userCreatedAt = timeNow
+                                   , userLastLogin = Nothing
+                                   , userDeletedAt = Nothing
+                                   }
+                -- assign all roles to the first user
+                mapM_ (insert_ . UserRole uid) [minBound .. maxBound]
+        _ -> return ()
 
     -- Return the foundation
-    return $ mkFoundation pool
+    return theFoundation
 
 -- | Convert our foundation to a WAI Application by calling @toWaiAppPlain@ and
 -- applyng some additional middlewares.
@@ -83,7 +116,7 @@
 
     -- Create the WAI application and apply middlewares
     appPlain <- toWaiAppPlain foundation
-    return $ logWare $ defaultMiddlewaresNoLogging appPlain
+    return $ logWare $ methodOverridePost appPlain
 
 -- | Warp settings for the given foundation value.
 warpSettings :: App -> Settings
